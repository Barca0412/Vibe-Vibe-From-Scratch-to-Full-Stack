---
title: "第二章：开发工具与 AI 调教指南"
---


![02-dev-tools-ai-tuning_index.png](../../public/images/Advanced/02-dev-tools-ai-tuning_index.png)
# 第二章：开发工具与 AI 调教指南





### 模型 vs 工具

环境装好了，你手里握着一份庞大的工具清单，面对 **Deepseek, 豆包, 千问, GLM, MiniMax, GPT, Claude, Gemini** 这些模型，还有 **Cursor, Trae, Windsurf** , **Qoder, Code Buddy** , **Antigravity** 这些编辑器，以及 **Claude Code, CodeX, Qoder CLI, Droid CLI, Warp** 等各种 CLI 命令行工具，你彻底晕了。

你不知道它们之间有什么区别。经过老师傅的介绍，你终于明白了：**模型决定代码能力的速度和上限，工具决定代码实现的方式和效率。** 最终，你在老师傅的介绍下选择了适合自己的开发组合。

说起模型，你可能会觉得既然 Claude 4.5 Opus 能力最强，就全部用它。但老师傅提醒你：**国产模型便宜且访问快，并拥有不俗的表现，Claude 贵**且存在网络环境问题（即使有很多中转站）。以 GLM 4.7 为例，每次 prompt 预计可调用模型 15-20 次，每月总计可用总量高达几十亿到数百亿 tokens，折算下来仅为 API 价格的 0.1 折，极具性价比。这个成本意识在 AI 原生开发中非常重要，否则规模上来后账单会让你震惊。



### 版本控制 Git 

看着你跃跃欲试准备让 AI 大改代码，老师傅突然按住了你的手，问了一个问题："**如果 AI 这一次改错了，把你本来能跑的代码改崩了，甚至把你昨天的功能覆盖了，你怎么办？**" 你意识到，如果没有版本控制，错误的修改可能导致之前的成果无法恢复。

老师傅告诉你，AI 编程非常激进，它可能为了修一个 Bug 而破坏三个旧功能。所以，在开始大规模开发之前，你必须配置好 **Git**。在这一阶段，你不需要懂什么复杂的"远程仓库"或"分支策略"，你只需要利用它建立高频的**本地版本记录**。

既然代码是 AI 写的，那么维护版本这种重复性工作也应该全权交给 AI，完全不需要你操心。老师傅传授了一句**写在 AI 规则里的指令**，让版本管理成为自动化的常规流程：

> **"每当你完成一个独立功能的开发，或修复完一个 Bug 并验证通过后，请自动运行 git commit 提交代码，并生成一句简洁的中文 commit message。"**

从此，你的开发流程变成了：AI 写完登录功能 → 自动存档；AI 写完首页 → 自动存档。一旦 AI 在写"个人中心"时把整个项目搞崩了，你不需要慌张，让 AI 帮你回退到上一个版本即可。这能确保在代码出现问题时迅速恢复，保障开发进度。

老师傅继续说："但用 Git 有一个大坑：如果不配置 `.gitignore`，很容易把敏感文件（如环境变量、密码）提交到云端仓库，造成严重的安全问题。**gitignore** 文件就是告诉 Git 哪些文件不应该被提交。**【详见第6章】** 详细配置。"



### 提示词工程

你跃跃欲试，想了一个 Demo 发过去，发现 AI 给的方案五花八门，中途有时候想按照自己的心意修改，结果改了这里坏了那里，引发连锁问题。

你觉得这三招已经很厉害了，基本能解决大部分问题。但你还是遇到了一些困惑：有时候 AI 还是会一本正经地胡说八道，给你编造根本不存在的接口；有时候你的提示词写得老长，效果反而不如简单几句；你甚至不知道什么时候、怎么描述任务。

老师傅告诉你，真正的高手不是靠配置，而是靠说话的艺术。这背后有一套提示词工程的心法。

老师傅让你做一个思想实验：想象你雇了一个**临时工**，这个人很能干，对你的行业了解很多，但不知道你公司的名字，也不知道你项目的具体背景。他第一天上班，直接对你说："嘿，我被告知有工作让我做，告诉我详情。"你会对他说什么？你会说"你是一个正在做图表的高中老师"吗？不会，你会直接告诉他任务："我们想让你检测图表的好坏。好的图表不需要完美，但要有坐标轴标记，大概高中水平就行。"**AI 就是这个临时工**。你不需要玩角色扮演，只需要清晰地传达任务上下文。

还有个问题：你遇到过 AI 不知道答案，但强行编造一个的情况。老师说，这是因为你没给 AI 一个"出口"。你应该告诉它："如果不确定，就明确说出来，等待我的确认，而不是强行编造。"

你还可以用类比帮助 AI 理解复杂概念、用录音转录的方式写提示词、让 AI 帮你改进提示词，甚至——知道什么时候该停下来，换个思路或者换个模型。

掌握这些心法后，你发现 AI 的输出质量显著提升。你知道什么时候该直接描述任务，什么时候该用类比，最重要的是——你知道 AI 的边界在哪里，不再让它做它不擅长的事。你的提示词越来越简洁，但效果却越来越好。





### 需求梳理

老师傅教你一个关键技巧：**让 AI 反复提问，直到问无可问**。你发现很多时候自己以为想清楚了需求，但 AI 写出来后发现不是那么回事。老师说，这是因为你的需求还有很多模糊地带。你应该在开始开发前，明确告诉 AI："**请反复问我问题，直到你完全理解我的需求为止。**" 这个过程看似浪费时间，实则是帮你理清思路——AI 问的每一个问题，都是你需求中的盲点。当 AI 问无可问时，你的需求也就真正清晰了。

你开始意识到需要统一标准。在老师傅的引导下，知道了要写 **PRD（产品需求文档，见下一节）**，并明白了"单一事实来源"的重要性：**不要让 AI 猜你想做什么，而是用文档告诉它必须做什么。**





## 配置技巧

除了选对工具，老师傅还传授了你三招让 AI 更加好用的技巧，解决了 AI 记性差、瞎胡写的问题：



### 项目规则

你之前总抱怨 AI 忘记你用的是 shadcn 还是 Tailwind，或者总是写错 TypeScript 类型。老师傅让你在项目根目录新建一个类似 **`.iderules`**（不同的工具名字可能不同）文件。你在里面写上："禁止使用 `any` 类型"、"强制使用 `pnpm`"、"修改之前必须考虑项目整体结构"。从此以后，AI 每次写代码前都会先参考这份**项目规范**，生成的代码质量瞬间提升，再也不胡乱引入你没安装的库了。

### 专属技能

针对 **Claude Code** 这样的 CLI 工具，老师傅教你创建或者安装 **Skills**。在这里，你可以用自然语言定义专属的指令，比如"每当我说'分析数据'时，就自动运行 `node scripts/analyze.js` 并总结结果"。这相当于为 AI 定义了一套标准作业流程，让它学会了你专属的工作流。

### 赋予能力

老师傅提到了 **MCP (Model Context Protocol)**和**插件 Plugins** 。以前你只能问 AI 问题，现在通过配置 MCP和插件，你可以让 AI **连接 GitHub 仓库**看代码，**连接 PostgreSQL 数据库**查数据，读取 **Figma** 设计稿，甚至接入 **Stripe** 支付。你不需要懂底层原理，只需要简单配置，你的 AI 就拥有了操作外部工具能力。

掌握这三招，你的 AI 已经变得聪明多了。但老师傅告诉你，这只是开始。还有更多让 AI 更懂你项目的方式，比如创建 **CLAUDE.md** 文件作为项目的"说明书"，配置 **Hooks** 让 AI 自动执行重复任务，或者创建专门的 **Subagents** 处理特定类型的工作。这些高级功能我们会在后续章节中逐步探索，现在先打好基础。





### 标准工作流

你庆幸自己选择了 AI IDE 或 CLI 工具，而不是在网页版对话框里手动复制粘贴。你发现，工具能直接读取你的项目上下文，生成的修改建议可以直接通过点击按钮无缝合并到代码中。这意味着你不会遇到那些手动复制粘贴时常犯的错误——比如不小心把 AI 偷懒生成的 `// ... rest of code` 注释也复制进文件导致程序崩溃。此外，你还发现可以给工具更高的权限，甚至某些工具还可以把消息推送到你的手机上，这样他们在执行大部分命令时都不需要你的批准，实现了高度的自动化，你可以趁机干自己的事情。

你深刻意识到：**Vibecoding 的核心不仅是 Prompt（提示词），更是 Workflow（工具流）。**

老师傅接着说，既然是讲工作流，那不能不提 Claude Code 的一些成熟模式。你之前是想到哪里做到哪里，让 AI 直接开写，但这样往往会导致返工。

推荐的标准流程是：**先探索项目结构，再规划实现步骤，然后编码，最后提交**。这听起来像废话，但你照着做了几次，发现效率确实提高不少——因为你不会写到一半才发现"哎呀，原来这个文件已经写过了"。

除了标准流程，还有一些实用技巧：指令要具体（"为登录页面添加测试"不如"为 app/login/page.tsx [手动拖入或者粘贴文件路径] 编写 Playwright 测试用例，覆盖密码错误、账号不存在的边缘情况"）、给 AI 看截图或设计图、明确告诉它要查看哪些文件。这些细节看似小事，但能显著减少来回沟通的次数。

你学会了在正确的时机使用正确的工作流，开发效率显著提升，更重要的是，你不再害怕大规模修改代码。

至于测试驱动开发（TDD）这类更专业的工作流，我们会在测试章节中深入讲解。



### 调试心法

在结束序言前，老师傅还传授了一套调试的心法。他说："有了AI，遇到错误不要慌。但要让AI帮你，你得学会正确的求助方式。"

他教你两个关键点：

**第一，提供完整报错日志**。新手看到满屏红色报错往往害怕，只复制最后一行，或者只说"报错了"。但AI就像医生，需要看到完整的症状才能准确诊断。你应该把那些**看起来最长、最复杂的红色错误信息——原封不动地全选、复制、发送给AI**。只有提供了完整的上下文，AI才能精准定位是哪一行代码出了问题，而不是在那儿盲目猜测。

**第二，循环修复模式**。如果AI第一次没修好，不要放弃。描述你尝试后的结果："我按你的方法改了，但现在出现了新的错误..."，让AI持续尝试。大多数Bug都需要2-3轮迭代才能解决。现在的AI工具甚至能直接读取你的终端报错，你只需要下令"帮我构建项目，检查所有报错并自动修复"，AI就会自动循环"运行-报错-修复"的过程，直到问题解决。

掌握了这套心法，你发现调试不再是恐惧时刻，而是与AI协作解决问题的过程。你不再害怕报错，因为你知道只要提供完整信息，AI总能帮你找到出路。



## MCP 开发实战 🟢

老师傅告诉你，MCP (Model Context Protocol) 是让 AI 连接外部世界的桥梁。通过 MCP，AI 可以读取数据库、查看 GitHub 仓库、调用 API、操作文件系统。

### MCP 的价值

以前 AI 只能和你对话，现在通过 MCP，AI 有了"手脚"。它可以：
- 连接 GitHub 仓库，读取代码历史
- 连接 PostgreSQL 数据库，查询数据
- 接入 Figma，读取设计稿
- 调用外部 API（如地图、支付、AI 服务）

### MCP 协议详解

MCP 是基于 **JSON-RPC 2.0** 的协议，支持三种资源类型：
- **工具 (Tools)**：AI 可以调用的函数
- **资源 (Resources)**：AI 可以读取的数据
- **提示 (Prompts)**：预定义的提示模板

### 部署 MCP 服务器

**本地部署（stdio）**：适合开发环境，进程直接通信。配置简单，但只能本地使用。

**远程部署（HTTP/SSE）**：适合生产环境，多用户共享。可以通过 Cloudflare Workers 或 Docker 部署。

**OAuth 身份认证**：当 MCP 需要访问第三方服务时，使用 OAuth 可以避免手动管理 API 密钥。OAuth 2.0 流程会自动处理令牌刷新。

### 实战案例

假设你想让 AI 能够读取公司内部的 API 文档，你可以：
1. 创建一个 MCP 服务器，暴露一个 `read_api_doc` 工具
2. AI 调用这个工具读取文档
3. 根据文档生成正确的 API 调用代码

这让 AI 能够访问私有知识库，大大扩展了它的能力边界。



## 多代理系统 🟢

随着项目变复杂，老师傅告诉你，有时候一个 AI 不够用，需要多个 AI 协同工作。

### 何时需要多代理系统

一个代理做复杂任务容易出错。比如：一个 AI 写代码，另一个 AI 审查；一个 AI 写测试，另一个 AI 写代码。这样能提高代码质量。

### 多代理协作模式

**并行处理**：一个代理写前端，另一个写后端。一个代理写文档，另一个写测试。

**串行处理**：第一个代理生成初稿，第二个代理审查，第三个代理优化。

**代理通信**：代理之间可以通过共享文件、共享上下文、或直接通信来协作。

**避免冲突**：任务分离——每个代理负责不同的领域。检查点——定期同步状态。冲突解决——明确的优先级规则。

### 多 Claude 工作流

你可以使用多个 Claude 实例并行工作。配合 Git worktrees（同一仓库的多个检出），可以同时处理多个功能分支。

**自定义斜杠命令**：为不同的代理创建专门的命令。比如 `/review` 触发审查代理，`/test` 触发测试代理。

### 集成到 CI/CD

多代理系统可以集成到 CI/CD 流程中：
- AI 自动分类 GitHub issue
- AI 自动修复 lint 错误
- AI 自动生成测试用例

这能大幅提高开发效率，但需要精心设计以避免代理之间的冲突。



## Hooks 安全防护 🟡

老师傅提醒你，Claude Code 的 Hooks 可以作为"守门员"，防止危险操作。

**危险命令拦截**：配置 Hooks 拦截 `rm -rf`、`git push` 等危险命令。要求用户二次确认。

**敏感文件写入验证**：禁止写入 `.env` 文件（必须交互式）。禁止修改 `.gitignore` 删除敏感规则。

**配置示例**：
```yaml
# .claude/hooks.yml
before_shell_command:
  - if: command.matches(/rm\s+-rf/)
    then: askConfirmation "这会删除文件，确定吗？"
  - if: filePath.includes('.env') && operation === 'write'
    then: reject "请手动编辑 .env 文件"
```



## 沙盒模式 🟢

当你需要完全隔离环境时，沙盒模式是最佳选择。

**什么是沙盒**：限制程序访问资源的系统。文件系统隔离——只能访问指定目录。网络隔离——禁止或限制网络访问。进程隔离——独立的运行环境。

**配置方法**：`--sandbox` 标志启用沙盒。可配置允许的文件路径。可配置网络访问规则。

**安全边界**：沙盒内程序无法访问系统文件。沙盒内程序无法执行任意命令。

**vs 容器的区别**：沙盒是进程级隔离，容器是系统级隔离。沙盒更轻量，容器更完整。

**适用场景**：运行不受信的代码。测试环境隔离。CI/CD 自动化构建。
